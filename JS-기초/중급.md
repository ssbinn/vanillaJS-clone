(수정 예정)

### 호이스팅 현상과 이유

- var 키워드와 함수 선언에서만 일어남

```jsx
console.log(a); // undefined
a=10;
console.log(a); // 10
var a = 20;
```

- 이 코드는 실제로 아래와 같이 동작함

```jsx
var a; // javascript는 변수와 함수의 선언을 실행 영역의 맨 앞으로 이동시켜 실행함
console.log(a); // undefined
a=10;
console.log(a); // 10
a = 20;
```

- 위 코드를 var 키워드가 아닌 let으로 고칠 경우, 첫번째 출력코드에서 a가 선언되지 않았다는 에러를 보임
- 호이스팅 이유
    - javascript는 변수와 함수의 선언 부분을 실행 영역의 맨 앞으로 이동해서 실행함
- 해결 방안
    - let, const만 사용할 것. 호이스팅이 var 키워드를 쓰지 않는 이유임
    - 함수 선언의 경우 함수 표현식으로 사용할 것
```javascript
// 함수 표현식 사용 예
getData(); // let으로 선언했기 때문에 선언되지 않았다는 에러를 보임

let getData = function() { ... } 
```

### 동기 / 비동기 처리

- 동기는 (syncronous) 요청을 보낸 후, 해당 요청의 응답을 받아야 다음 동작을 실행
- 비동기 (Asyncronous)는 요청을 보낸 후, 응답과 관계없이 다음 동작을 실행한다.
- 대부분의 프로그래밍 언어는 동기적 처리를 지향함. 자바스크립트도 동기적 처리가 기본이지만, 일부 기능은(실행이 오래걸리는 동작) 비동기적으로 처리가 가능하도록 기능을 추가로 제공하고 있다.

주요 비동기적 처리

- Rest API 요청
- 파일/데이터베이스 처리
- 타이머, 암호화/복호화 등

예시

```jsx
console.log('안뇽');
setTimeout (() => { // 비동기적 처리 함수
	console.log('ssbinn'); // 이 동작이 완료되지 않았는데
}, 3000);

console.log('룰루랄라'); // 이 코드가 먼저 실행됨
```

출력

```jsx
안뇽
룰루랄라
ssbinn
```

#### 비동기처리의 문제점

- Rest API를 호출해서 결과 값을 받고, 그 결과 값을 기반으로 코드를 실행하는 경우를 예로들자. 해당 함수를 호출한 뒤 결과 값을 받지 않은 채로 다음 코드가 실행되면 전체 코드 실행에 영향을 끼칠 수 있음

해결 방법 - 콜백함수

- 자바스크립트에서 함수는 `first-class function` 이기 때문에 콜백함수를 만들 수 있음
    - 함수 자체를 변수에 저장 가능
    - 함수의 인자에 다른 함수를 인수로 전달 가능
    - 함수의 반환값에 함수를 전달 가능
- **콜백 함수를 first-class function을 이용해 사용하는 방법**

예시

```jsx
console.log('안뇽');

function desc(callback) {
	setTimeout (() => { 
		console.log('ssbinn'); 
		callback();
	}, 3000);
}
function desc2() {
	console.log('룰라랄라');
}

desc(desc2);
```

출력

```jsx
안뇽
ssbinn
룰루랄라
```

- 그렇지만 `콜백 지옥`의 또 다른 문제점이 생김

### Promise

- ES6에서 공식적으로 추가된 문법으로, 비동기 처리를 위한 콜백함수의 단점(콜백지옥)을 극복하기 위해 제안됨
- then으로 계속계속 이어지는 코드구나
